/*
Auto-generated by C4D to R3F Converter
Model: halfCylinder.glb
*/

import * as THREE from 'three'
import { useMemo } from 'react'
import { useGLTF } from '@react-three/drei'
import { ConvexHullCollider } from '@react-three/rapier'
import type { ThreeElements } from '@react-three/fiber'
import { C4DMesh, C4DMaterial, GameRigidBody } from '@/scene/SceneComponents'
import type { GamePhysicsBodyType } from '@/scene/SceneComponents'
import type { MaterialColorIndex, Vec3 } from '@/settings/GameSettings'
import modelUrl from './halfCylinder.glb?url'

type GeneratedRigidBodySettings = {
  type: GamePhysicsBodyType
  mass?: number
  friction?: number
  restitution?: number
  lockRotations?: boolean
  sensor?: boolean
  contagionCarrier?: boolean
  contagionInfectable?: boolean
}

export type HalfCylinderProps = ThreeElements['group'] & {
  materialColor0?: MaterialColorIndex
  materialHidden0?: boolean
  singleTone?: boolean
  physics?: GamePhysicsBodyType
  mass?: number
  friction?: number
  restitution?: number
  lockRotations?: boolean
  linearVelocity?: Vec3
  angularVelocity?: Vec3
  linearDamping?: number
  angularDamping?: number
  entityId?: string
  contagionCarrier?: boolean
  contagionInfectable?: boolean
  contagionColor?: MaterialColorIndex
  rigidBodyOne?: Partial<GeneratedRigidBodySettings>
}

const PRIMARY_MESH_KEY = 'halfCynlinder_dynamic_color1_collision'

function coerceRigidBodyType(value: unknown): GamePhysicsBodyType | undefined {
  if (value === 'fixed'
    || value === 'dynamic'
    || value === 'kinematicPosition'
    || value === 'kinematicVelocity'
    || value === 'noneToDynamicOnCollision'
    || value === 'solidNoneToDynamicOnCollision'
    || value === 'animNoneToDynamicOnCollision') {
    return value
  }
  return undefined
}

function resolveMesh(nodes: Record<string, THREE.Mesh>): THREE.Mesh {
  const primary = nodes[PRIMARY_MESH_KEY]
  if (primary?.isMesh) return primary
  const fallback = Object.values(nodes).find((node) => node?.isMesh)
  if (fallback) return fallback
  throw new Error('HalfCylinder mesh node not found in GLTF.')
}

export function HalfCylinder({
  materialColor0 = 1,
  materialHidden0 = false,
  singleTone = true,
  physics,
  mass,
  friction,
  restitution,
  lockRotations,
  linearVelocity,
  angularVelocity,
  linearDamping,
  angularDamping,
  entityId,
  contagionCarrier,
  contagionInfectable,
  contagionColor,
  rigidBodyOne,
  ...props
}: HalfCylinderProps) {
  const { nodes } = useGLTF(modelUrl) as unknown as { nodes: Record<string, THREE.Mesh> }
  const meshNode = useMemo(() => resolveMesh(nodes), [nodes])

  const resolvedRigidBody = useMemo<GeneratedRigidBodySettings | null>(() => {
    const mergedType = coerceRigidBodyType(physics ?? rigidBodyOne?.type)
    if (!mergedType) return null

    return {
      type: mergedType,
      ...((mass ?? rigidBodyOne?.mass) !== undefined ? { mass: mass ?? rigidBodyOne?.mass } : {}),
      ...((friction ?? rigidBodyOne?.friction) !== undefined ? { friction: friction ?? rigidBodyOne?.friction } : {}),
      ...((restitution ?? rigidBodyOne?.restitution) !== undefined ? { restitution: restitution ?? rigidBodyOne?.restitution } : {}),
      ...((lockRotations ?? rigidBodyOne?.lockRotations) === true ? { lockRotations: true } : {}),
      ...(rigidBodyOne?.sensor === true ? { sensor: true } : {}),
      contagionCarrier: contagionCarrier === true,
      contagionInfectable: contagionInfectable !== false,
    }
  }, [
    physics,
    rigidBodyOne?.type,
    rigidBodyOne?.mass,
    rigidBodyOne?.friction,
    rigidBodyOne?.restitution,
    rigidBodyOne?.lockRotations,
    rigidBodyOne?.sensor,
    mass,
    friction,
    restitution,
    lockRotations,
    contagionCarrier,
    contagionInfectable,
  ])

  const resolvedContagionColor = contagionColor ?? materialColor0
  const colliderRestitutionProps = Number.isFinite(resolvedRigidBody?.restitution) ? { restitution: resolvedRigidBody?.restitution } : {}

  const mesh = (
    <C4DMesh
      name={meshNode.name}
      geometry={meshNode.geometry}
      castShadow
      receiveShadow
      visible={!materialHidden0}
    >
      <C4DMaterial color={materialColor0} singleTone={singleTone} />
    </C4DMesh>
  )

  if (!resolvedRigidBody) {
    return (
      <group {...props} dispose={null}>
        <group name="">
          {mesh}
        </group>
      </group>
    )
  }

  return (
    <group {...props} dispose={null}>
      <group name="">
        <GameRigidBody
          type={resolvedRigidBody.type}
          {...(resolvedRigidBody.mass !== undefined ? { mass: resolvedRigidBody.mass } : {})}
          {...(resolvedRigidBody.friction !== undefined ? { friction: resolvedRigidBody.friction } : {})}
          {...(resolvedRigidBody.lockRotations ? { lockRotations: true } : {})}
          {...(resolvedRigidBody.sensor ? { sensor: true } : {})}
          {...(linearVelocity !== undefined ? { linearVelocity } : {})}
          {...(angularVelocity !== undefined ? { angularVelocity } : {})}
          {...(linearDamping !== undefined ? { linearDamping } : {})}
          {...(angularDamping !== undefined ? { angularDamping } : {})}
          colliders={false}
          contagion={{
            entityId,
            carrier: resolvedRigidBody.contagionCarrier === true,
            infectable: resolvedRigidBody.contagionInfectable !== false,
            colorIndex: resolvedContagionColor,
          }}
        >
          <ConvexHullCollider args={[meshNode.geometry.attributes.position.array]} {...colliderRestitutionProps} />
          {mesh}
        </GameRigidBody>
      </group>
    </group>
  )
}

useGLTF.preload(modelUrl)
